#!/bin/sh

# This was stolen/adapted from stassats's eval-in-swank.sh script.
# It doesn't actually output to swank anymore. :-(

if [ -z "$SCRIPTL_PORT" ]; then
    SCRIPTL_PORT=4010
fi

encode_length () {
    printf %08X ${#1}
}

encode_packet () {
    encode_length "$1"
    echo -n "$1"
}

hex_to_decimal () {
    printf %d "0x$1"
}

read_length () {
    hex_to_decimal `head -c 8`
}

read_packet () {
    head -c `read_length`
}

encode_args () {
    for i in "$@"; do
        encode_packet "$i"
    done
}

parse () {
    read status

    if [ "$status" = ":ok" ]; then
        ret=`read_packet`
        out=`read_packet`

        if [ -z "$out" ]; then
            echo "$ret"
        else
            echo "$out"
        fi
    else
        read err
        str=`read_packet`

        echo "Error: $err"
        echo
        echo $str
    fi
}

if [ $# = 0 ]; then
    echo "Usage: funcall FUNCTION [arg1 ...]"
    echo
    echo "Example: funcall PRINT \"hello world\""
    echo
    echo "Note: All arguments are passed as strings, so functions which"
    echo "      take non-string arguments won't work here.  But you can"
    echo "      test your own functions this way."
    exit 1
fi

{
    cmd="$1"
    shift
    echo "(:scriptl 1)"
    echo "(:cwd #P\"`pwd`/\")"
    echo "(:funcall $# #P\"$0\")"
    echo "(:errors nil)"
    echo "$cmd"
    encode_args "$@"
} | nc localhost $SCRIPTL_PORT | parse
